---
title: "Notes on ggplot app"
author: "Danny Kaplan"
date: "June 10, 2015"
output: html_document
runtime: shiny
---

```{r include=FALSE}
library(ggplot2)
library(mosaicData)
```

Name aesthetics for each geom type:

```{r}
geom_aesthetics <- list(
  geom_line  = list(x="any", y="any", 
                    color = "few", size="num_or_few", type="few",
                    group = "few"),
  geom_point = list(x="any", y="any", 
                    color="num_or_few", size ="num_or_few", alpha="num_or_few"),
  geom_bar   = list(x="any", y="any", color = "few", position = "bar_positions")
)
```

Set up the reactive state.  When these change, the plot should change automatically. Note: they are assigned globally.
```{r}
layer_1_values <<- 
  reactiveValues(
    layer = 1,
    data = KidsFeet, 
    geom = "geom_point",
    mappings = list(x="length", y="width", shape="sex", color=NULL), 
    settings = list(color="red", size=4) # any that are mapped must be absent.
  ) 
layer_2_values <<-
  reactiveValues(
    layer = 2,
    data = KidsFeet,
    geom = "geom_text",
    mappings = list(x="length", y="width", label="name", color="sex"),
    settings = list(size = 4)
  )
```

A general format for layer controls.
```{r}
inputPanel(
  wellPanel(
    textOutput("controls"),
    selectInput("geom1", "Geom for this layer:",
                list("none"="geom_blank", 
                     "geom_point", "geom_line", "geom_bar")),
    uiOutput("layer_controls_1") 
  )
)
observe({
  layer_1_values$geom <<- input$geom1 
  # remember, assignment is <<- for assignment at higher level
})
output$controls <- renderText(names(input))
```

Observe the choice of geom and set up the custom UI suited to that choice:
```{r}
output$layer_controls_1 <-
  renderUI({
    this_data_table <- layer_1_values$data
    these_controls  <- geom_aesthetics[[layer_1_values$geom]]
    html_for_controls <- ""
    for (nm in names(these_controls)) {
      new_html <- 
        selectInput(inputId = paste0("aes_layer_", 1, "_", nm), 
                    label = nm,
                    choices = c(none = "none", names(this_data_table)), 
                    selected = "none" # or see if the frame vars exist for x and y and set those as the selected.
                    
                    )
        html_for_controls <- paste(html_for_controls, new_html)
    }
    
    HTML(html_for_controls)
  })                              
```


Handle any change in the aesthetics for layer 1 by changing `layer_1_values`.
```{r}
observe({
  input$aes_layer_1_x; input$aes_layer_1_y; input$aes_layer_1_color; 
  # and so on.  Isn't there a way to compute this dependency
  
  # Get the relevant inputs for this layer
  NMS <- names(input)
  NMS <- NMS[grepl("^input$aes_layer_1", NMS)]

  for (nm in NMS) {
    val <- input[nm]
    aes_name <- gsub("^input$aes_layer_1_", "", nm)
    if (val != "none") layer_1_values$mappings[[aes_name]] <<- val
    cat("hello\n", file=stdout())
  }
})
```


```{r}
inputPanel(
  selectInput("shape", "Map shape to:", 
              choices = names(KidsFeet)),
  selectInput("color", "Set color to:",
              choices = list("red", "blue", "green"))
)
```

```{r}
observe({
  layer_1_values$mappings$shape <<- input$shape
})
observe({
  layer_1_values$settings$color <<- input$color
})
```
  
```{r}
make_geom_argument_list <- function(values) {
  non_null_mappings <- 
    values$mappings[!unlist(lapply(values$mappings,FUN=is.null))]
  non_null_settings <-
    values$settings[!unlist(lapply(values$settings,FUN=is.null))]
  # make sure there's no overlap
  not_in_mappings <- setdiff(names(non_null_settings), names(non_null_mappings))
  arg_list <- non_null_settings[not_in_mappings]
  arg_list$mapping <- do.call(aes_string, non_null_mappings)
  
  arg_list
}
```

```{r out.width="50%"}
renderPlot({
  ggplot(data=layer_1_values$data) +  
       do.call(layer_1_values$geom, 
               make_geom_argument_list(layer_1_values)) +
       do.call(layer_2_values$geom, 
               make_geom_argument_list(layer_2_values))
})
```

